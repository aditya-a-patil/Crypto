import requests, json

from Crypto.Hash import SHA
from Crypto.PublicKey import RSA
from M2Crypto import DSA

from base64 import b64decode
import base64

global url, headers
server = '127.0.0.1'
port = '80'
url = {}
headers = {}

#UTILITY methods
def encodeBase64(s):
    return base64.b64encode(s)

def decodeBase64(strBase64):
    return base64.b64decode(strBase64)

def retrieveCiphertext(cipher, n):
    return cipher.split(" ")[n]

def xor(s1,s2):    
    # convert strings to a list of character pair tuples
    # go through each tuple, converting them to ASCII code (ord)
    # perform exclusive or on the ASCII code
    # then convert the result back to ASCII (chr)
    # merge the resulting array of characters as a string
    return ''.join(chr(ord(a) ^ ord(b)) for a,b in zip(s1,s2))

def writeToFile(filename, contents):
    f = open(filename,'w')
    f.write(contents)
    f.close()

#REST methods
def setupNetworkStrings(server, port):

    if 'http' in server:
        host = server+':'+port
    else:
        host = 'http://'+server+':'+port

    url['lookupUsers'] = host+'/lookupUsers'
    url['lookupKey'] = host+'/lookupKey/'
    url['registerKey'] = host+'/registerKey/'
    url['getMessages'] = host+'/getMessages/'
    url['sendMessage'] = host+'/sendMessage/'
    headers['content-type'] = 'application/json'

def lookupKey(username):
    r = requests.get(url['lookupKey']+str(username))
    return r

def lookupUsers():
    users = requests.get(url['lookupUsers'], headers=headers)
    for i in range(users.json()["numUsers"]):
        print '%d : %s' %(i, users.json()["users"][i])

def registerKey(PUBLIC_KEY, user):
    payload = {}
    payload['keyData'] = str(PUBLIC_KEY)
    r = requests.post(url['registerKey']+str(user), data=json.dumps(payload), headers=headers)
    if r.json()["result"] == 1:
        print 'Successfully registered a public key for %s .' % user
    else:
        print 'Failed to register a public key for %s .' % user

def getMessages(user):
    r = requests.get(url['getMessages']+str(user), headers=headers)
    return r

def sendMSG(msgID, cipherText, suser, ruser):
    payload = {}
    payload['recipient'] = ruser
    payload['messageID'] = msgID
    payload['message'] = cipherText
    
    r = requests.post(url['sendMessage']+suser, data=json.dumps(payload), headers=headers)
    if r.json()["result"] == 1:
        print 'Message sent.'
    else:
        print 'Failed to send message'

#CRYPTO methods

def computeSHA1(content):
    hashObj = SHA.new()
    hashObj.update(content)
    return hashObj.digest()

def rsaKeyGen(user):
    rsa_key = RSA.generate(1024)
    rsa_public_key = rsa_key.publickey().exportKey('DER')

    #write rsa private key to file
    filename_rsa = '%s_rsa_key.der' % user
    writeToFile(filename_rsa, rsa_key.exportKey('DER'))

    return base64.b64encode(rsa_public_key)

def dsaKeyGen(user):
    dsa = DSA.gen_params(1024)
    dsa.gen_key()
    filename_dsa_private = '%s_dsa_private.pem' % user
    dsa.save_key(filename_dsa_private, cipher=None)
    filename_dsa_public = '%s_dsa_public.pem' % user
    dsa.save_pub_key(filename_dsa_public)

    lines_list_nonewline = []
    lines_list = open(filename_dsa_public).readlines()
    for i in lines_list:
        lines_list_nonewline.append(i.rstrip('\n'))
        
    return ''.join(lines_list_nonewline[1:-1])

def genKeys(adversary):
    print 'Generating a new keypair for %s' % adversary
    rsa_public_key_base64 = rsaKeyGen(adversary)
    dsa_public_key_base64 = dsaKeyGen(adversary)
    PUBLIC_KEY = rsa_public_key_base64 + '%' + dsa_public_key_base64
    registerKey(PUBLIC_KEY, adversary)

def generateSignature(message, user):
    filename_dsa_private = '%s_dsa_private.pem' % user
    dsa = DSA.load_key(filename_dsa_private)
    cipher_preDSA_hash = computeSHA1(message)
    return dsa.sign_asn1(cipher_preDSA_hash)

#EXPLOIT methods

#Part 2
def maul(msg, recipient):
	
	for i in range(msg.json()['numMessages']):

		sender = ''

		#parse MSG
		if msg.json()['messages'][i]['senderID'] == 'alice':
			sender = 'aloce'
		else:
			sender = 'bod'
		genKeys(sender)
		msgID = msg.json()['messages'][i]['messageID']
		cipher = msg.json()['messages'][i]['message']
		

		#Parse ciphertext
		ciphertext1_base64 = retrieveCiphertext(cipher, 0).encode('utf-8')
		ciphertext2_base64 = retrieveCiphertext(cipher, 1)

	    #Base64 decode ciphertext
		ciphertext1 = decodeBase64(ciphertext1_base64)
		ciphertext2 = decodeBase64(ciphertext2_base64)

		print 'cipher \n%s\n' % cipher
		print 'ciphertext2_base64 \n%s\n' % ciphertext2_base64

		ciphertext2_base64 = encodeBase64(ciphertext2[:18] + xor(ciphertext2[18], '\x06') + ciphertext2[19:])
		
		ciphertext2 = decodeBase64(ciphertext2_base64)
		ciphertext2_base64 = encodeBase64(ciphertext2[:23] + xor(ciphertext2[23], '\x04') + ciphertext2[24:])
		
		cipher_preDSA = (ciphertext1_base64 + " " + ciphertext2_base64)
		signature_adversary = generateSignature(cipher_preDSA, sender)
		signature_adversary_base64 = base64.b64encode(signature_adversary)

		cipher_mauled = ciphertext1_base64 + " " + ciphertext2_base64 + " " + signature_adversary_base64
		print 'cipher_mauled \n%s\n' % cipher_mauled
		print 'ciphertext2_base64 \n%s\n' % ciphertext2_base64

		sendMSG(msgID, cipher_mauled, sender, recipient)

#Part 1
def intercept(recipient):
	msg = getMessages(recipient)
	#print msg.json()
	if msg.json()['numMessages'] > 0:
		for i in range(msg.json()['numMessages']):
		    sender = msg.json()['messages'][i]['senderID']
		    msgID = msg.json()['messages'][i]['messageID']
		    cipher = msg.json()['messages'][i]['message']
		    #sendMSG(msgID, cipher, sender, recipient)

		    print 'Sender: %s' % sender
		    print 'msgID: %d' % msgID
		    print 'Message #%d \n' % i
		    #print cipher

		    maul(msg, recipient)
		    
		    

if __name__ == "__main__":

	setupNetworkStrings(server, port)

	while 1==1:
		option = raw_input('> ')

		if option == '':
			intercept('bob')
		else:
			intercept(option)
		#elif 'tap ' in option:
		#	print intercept(option.split(" ")[1])
    	
	




