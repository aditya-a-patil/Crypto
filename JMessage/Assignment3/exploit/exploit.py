import requests, json

import sched, time

from Crypto import Random
from Crypto.Cipher import PKCS1_v1_5
from Crypto.Hash import SHA
from Crypto.PublicKey import RSA
from M2Crypto import DSA
import M2Crypto, binascii

from base64 import b64decode
import base64
import os


global url, headers
server = '127.0.0.1'
port = '80'
url = {}
headers = {}

#Logging
import logging
logging.basicConfig(format='[%(levelname)s]: %(message)s', level=logging.DEBUG)

#global variable for Part 1
global intercepted_msg
intercepted_msg = False

s = sched.scheduler(time.time, time.sleep)

#UTILITY methods
def unpad(s):
	return s[0:-ord(s[-1])]

def encodeBase64(s):
	return base64.b64encode(s)

def decodeBase64(strBase64):
	return base64.b64decode(strBase64)

def retrieveKey(KEY, mode):
	if mode == 'RSA':
		return KEY.split("%")[0]
	else:
		return KEY.split("%")[1]

def retrieveCiphertext(cipher, n):
	return cipher.split(" ")[n]

def xor(s1,s2):    
	# convert strings to a list of character pair tuples
	# go through each tuple, converting them to ASCII code (ord)
	# perform exclusive or on the ASCII code
	# then convert the result back to ASCII (chr)
	# merge the resulting array of characters as a string
	return ''.join(chr(ord(a) ^ ord(b)) for a,b in zip(s1,s2))

def writeToFile(filename, contents):
	f = open(filename,'w')
	f.write(contents)
	f.close()

def createPEM(key):
	header = '-----BEGIN PUBLIC KEY-----\n'
	footer = '\n-----END PUBLIC KEY-----'
	key_pem = header + key + footer
	return key_pem

def deleteFile(filename):
	os.remove(filename)


#REST methods
def setupNetworkStrings(server, port):

	if 'http' in server:
		host = server+':'+port
	else:
		host = 'http://'+server+':'+port

	url['lookupUsers'] = host+'/lookupUsers'
	url['lookupKey'] = host+'/lookupKey/'
	url['registerKey'] = host+'/registerKey/'
	url['getMessages'] = host+'/getMessages/'
	url['sendMessage'] = host+'/sendMessage/'
	headers['content-type'] = 'application/json'

def lookupKey(username):
	r = requests.get(url['lookupKey']+str(username))
	return r

def lookupUsers():
	users = requests.get(url['lookupUsers'], headers=headers)
	for i in range(users.json()["numUsers"]):
		print '%d : %s' %(i, users.json()["users"][i])

def registerKey(PUBLIC_KEY, user):
	payload = {}
	payload['keyData'] = str(PUBLIC_KEY)
	r = requests.post(url['registerKey']+str(user), data=json.dumps(payload), headers=headers)
	if r.json()["result"] == 1:
		logging.info('Successfully registered a public key for %s .' % user)
	else:
		logging.error('Failed to register a public key for %s .' % user)

def getMessages(user):
	r = requests.get(url['getMessages']+str(user), headers=headers)
	return r


def sendMSG(msgID, cipherText, suser, ruser):
	payload = {}
	payload['recipient'] = ruser
	payload['messageID'] = msgID
	payload['message'] = cipherText
	
	r = requests.post(url['sendMessage']+suser, data=json.dumps(payload), headers=headers)
	if r.json()["result"] == 1:
		logging.info('Message sent.')
	else:
		logging.error('Failed to send message')

#CRYPTO methods

def computeSHA1(content):
	hashObj = SHA.new()
	hashObj.update(content)
	return hashObj.digest()

def rsaKeyGen(user):
	rsa_key = RSA.generate(1024)
	rsa_public_key = rsa_key.publickey().exportKey('DER')

	#write rsa private key to file
	filename_rsa = '%s_rsa_key.der' % user
	writeToFile(filename_rsa, rsa_key.exportKey('DER'))

	return base64.b64encode(rsa_public_key)

def dsaKeyGen(user):
	dsa = DSA.gen_params(1024)
	dsa.gen_key()
	filename_dsa_private = '%s_dsa_private.pem' % user
	dsa.save_key(filename_dsa_private, cipher=None)
	filename_dsa_public = '%s_dsa_public.pem' % user
	dsa.save_pub_key(filename_dsa_public)

	lines_list_nonewline = []
	lines_list = open(filename_dsa_public).readlines()
	for i in lines_list:
		lines_list_nonewline.append(i.rstrip('\n'))
		
	return ''.join(lines_list_nonewline[1:-1])

def genKeys(adversary):
	logging.info('Generating a new keypair for %s' % adversary)
	rsa_public_key_base64 = rsaKeyGen(adversary)
	dsa_public_key_base64 = dsaKeyGen(adversary)
	PUBLIC_KEY = rsa_public_key_base64 + '%' + dsa_public_key_base64
	registerKey(PUBLIC_KEY, adversary)

def generateSignature(message, user):
	filename_dsa_private = '%s_dsa_private.pem' % user
	dsa = DSA.load_key(filename_dsa_private)
	cipher_preDSA_hash = computeSHA1(message)
	return dsa.sign_asn1(cipher_preDSA_hash)

def verifySignature(key, message, signature):
	key_pem = createPEM(key)
	filename = 'sender_dsa_key.pem'
	writeToFile(filename, key_pem)
	message_base64_hash = computeSHA1(message)
	dsa = DSA.load_pub_key(filename)
	verification = dsa.verify_asn1(message_base64_hash, signature)
	deleteFile(filename)
	return verification

def rsaDecryption(user, cipher):
	rsa_privatekey_filename = '%s_rsa_key.der'%user
	f_rsa_pem = open(rsa_privatekey_filename,'r')
	rsaKey = RSA.importKey(f_rsa_pem.read())

	dsize = SHA.digest_size
	sentinel = Random.new().read(0+dsize)
	cipher1 = PKCS1_v1_5.new(rsaKey)
	return cipher1.decrypt(cipher, sentinel)

def aesDecryption( key, ciphertext, iv):
	cryptor = M2Crypto.EVP.Cipher( alg='aes_128_ctr', key=key, iv=iv, op=0)
	ret = cryptor.update( ciphertext )
	ret = ret + cryptor.final()
	return ret

def verifyCRC(msg_crc):
	msg_formatted = msg_crc[:-4]
	crc_old = msg_crc[-4:]
	crc_new = binascii.crc32(msg_formatted)
	crc_new = binascii.unhexlify('%08X' % (crc_new & 0xffffffff))

	if crc_old != crc_new:
		print False
	else:
		return True

def decrypt(cipher, sender, msgID, user):

	key_request = lookupKey(sender)
	KEY = key_request.json()['keyData']
	
	message = 'No new messages.'
	
	#1
	dsaKey = retrieveKey(KEY, 'DSA')

	#2
	ciphertext1_base64 = retrieveCiphertext(cipher, 0).encode('utf-8')
	ciphertext2_base64 = retrieveCiphertext(cipher, 1).encode('utf-8')
	message_base64 = (" ".join(cipher.split(" ")[:2])).encode('utf-8')
	signature_base64 = retrieveCiphertext(cipher, 2).encode('utf-8')

	#3
	ciphertext1 = decodeBase64(ciphertext1_base64)
	ciphertext2 = decodeBase64(ciphertext2_base64)
	signature = decodeBase64(signature_base64)

	#4    
	signature = verifySignature(dsaKey, message_base64, signature)
	if not signature:
		message = 'BAD SIGNATURE'
		return message

	#5
	plaintext1_aes_key = rsaDecryption(user, ciphertext1)

	#6
	iv = ciphertext2[:16]
	
	ciphertext2 = ciphertext2[16:]
	msg_padded = aesDecryption(plaintext1_aes_key, ciphertext2, iv)

	#7
	msg_crc = unpad(msg_padded)

	#8
	msg_formatted = msg_crc[:-4]

	crc = verifyCRC(msg_crc)   
	if not crc:
		message = 'BAD CRC'
		return message
	
	#9
	sender_userid = msg_formatted.split(":")[0]

	if sender_userid != sender:
		message = 'BAD USER'
		return message
	else:
		message = msg_formatted.split(":")[1]

	#10 - Output M
	return message

#MISC

def get_padlen(adversary):
	first_pass_read_rcpts = getMessages(adversary)

	global padlen
	padlen = 16
	if first_pass_read_rcpts.json()['numMessages'] > 0:
		for i in range(first_pass_read_rcpts.json()['numMessages']):
			sender = first_pass_read_rcpts.json()['messages'][i]['senderID']
			cipher = first_pass_read_rcpts.json()['messages'][i]['message']
			msgID = first_pass_read_rcpts.json()['messages'][i]['messageID']

			read_rcpt = decrypt(cipher, sender, msgID, adversary)
			print read_rcpt

			if padlen>int(read_rcpt.split(" ")[1]):
				padlen = int(read_rcpt.split(" ")[1])

	print 'PAD LENGTH = %d' % padlen

def format_padded_cipher(cipher, padlength):

	ciphertext1_base64 = retrieveCiphertext(cipher, 0).encode('utf-8')
	ciphertext2_base64 = retrieveCiphertext(cipher, 1)
	signature_base64 = retrieveCiphertext(cipher, 2).encode('utf-8')

	ciphertext2 = decodeBase64(ciphertext2_base64)



	new_padlen = xor(str(padlength), str(padlength+1))
	print new_padlen.encode('hex')
	
	last_position = len(ciphertext2)-1

	for i in range(padlength):
		ciphertext2 = ciphertext2[:last_position-i] + xor(ciphertext2[last_position-i], new_padlen) + ciphertext2[last_position-(i-1):]

	ciphertext2_base64 = encodeBase64(ciphertext2)

	padded_cipher = ciphertext1_base64 + " " + ciphertext2_base64 + " " + signature_base64

	return padded_cipher

#EXPLOIT methods
#Part 3
def attack(msgID, cipher, sender, recipient, xor_char, xor_pos, isPass1):

		print 'xor_pos %d' % xor_pos
		print xor_char
		ciphertext1_base64 = retrieveCiphertext(cipher, 0).encode('utf-8')
		ciphertext2_base64 = retrieveCiphertext(cipher, 1)
		ciphertext2 = decodeBase64(ciphertext2_base64)

		#Maul sender ID
		ciphertext2_base64 = encodeBase64(ciphertext2[:18] + xor(ciphertext2[18], '\x06') + ciphertext2[19:])
		
		#Maul message
		
		ciphertext2 = decodeBase64(ciphertext2_base64)
		last_position = len(ciphertext2)-1

		#ciphertext2_base64 = encodeBase64(ciphertext2[0:last_position] + xor(ciphertext2[last_position:], hex(xor_char)))
		if isPass1:
			print 'in PASS1'
			ciphertext2_base64 = encodeBase64(ciphertext2[:last_position-xor_pos] + xor(ciphertext2[last_position-xor_pos], str(xor_char)) + ciphertext2[last_position-(xor_pos-1):])
		else:
			print str(xor_char)
			print str(xor_pos+1)
			#xor_char1 = xor(str(xor_char), str(xor_pos+1)) 	#since xor_pos is padlen
			xor_char1 = chr(xor_char ^ (xor_pos+1))
			print xor_char1.encode('hex')
			ciphertext2_base64 = encodeBase64(ciphertext2[:last_position-xor_pos] + xor(ciphertext2[last_position-xor_pos], xor_char1) + ciphertext2[last_position-(xor_pos-1):])
			print last_position-xor_pos
			print last_position-xor_pos
			print last_position-(xor_pos-1)
			
			
		#Recompute signature
		cipher_preDSA = (ciphertext1_base64 + " " + ciphertext2_base64)
		signature_adversary = generateSignature(cipher_preDSA, sender)
		signature_adversary_base64 = base64.b64encode(signature_adversary)

		cipher_mauled = ciphertext1_base64 + " " + ciphertext2_base64 + " " + signature_adversary_base64
		#print 'cipher_mauled \n%s\n' % cipher_mauled
		
		logging.info('Sending Mauled message to POODLE')
		s.enter(0.3, 1, sendMSG, (msgID, cipher_mauled, sender, recipient,))
		s.run()

#		sendMSG(msgID, cipher_mauled, sender, recipient)


#Part 2
def maul(msg, recipient):
	
	for i in range(msg.json()['numMessages']):

		msgID = msg.json()['messages'][i]['messageID']
		cipher = msg.json()['messages'][i]['message']

		logging.info('Maulling encypted message with messageID %d' % msgID)
		
		#Set adversary name and generate keys
		sender = ''
		if msg.json()['messages'][i]['senderID'] == 'alice1':
			sender = 'aloce1'
		else:
			sender = 'bod2'
		genKeys(sender)
		
		#Parse ciphertext
		ciphertext1_base64 = retrieveCiphertext(cipher, 0).encode('utf-8')
		ciphertext2_base64 = retrieveCiphertext(cipher, 1)

		#Base64 decode ciphertext
		ciphertext1 = decodeBase64(ciphertext1_base64)
		ciphertext2 = decodeBase64(ciphertext2_base64)

		#print 'cipher \n%s\n' % cipher
		#print 'ciphertext2_base64 \n%s\n' % ciphertext2_base64

		ciphertext2_base64 = encodeBase64(ciphertext2[:18] + xor(ciphertext2[18], '\x06') + ciphertext2[19:])
		
		ciphertext2 = decodeBase64(ciphertext2_base64)
		ciphertext2_base64 = encodeBase64(ciphertext2[:26] + xor(ciphertext2[26], '\x04') + ciphertext2[27:])
		
		cipher_preDSA = (ciphertext1_base64 + " " + ciphertext2_base64)
		signature_adversary = generateSignature(cipher_preDSA, sender)
		signature_adversary_base64 = base64.b64encode(signature_adversary)

		cipher_mauled = ciphertext1_base64 + " " + ciphertext2_base64 + " " + signature_adversary_base64
		#print 'cipher_mauled \n%s\n' % cipher_mauled
		
		logging.info('Sending Mauled message')
		sendMSG(msgID, cipher_mauled, sender, recipient)

#Part 1
def start_interception(recipient, isMaul):
	msg = getMessages(recipient)
	#print msg.json()
	if msg.json()['numMessages'] > 0:
		global intercepted_msg
		intercepted_msg = True
		for i in range(msg.json()['numMessages']):
			sender = msg.json()['messages'][i]['senderID']
			msgID = msg.json()['messages'][i]['messageID']
			cipher = msg.json()['messages'][i]['message']

			logging.info('Intercepted encrypted message from %s' % sender)
			logging.info('Message ID of intercepted message: %d' % msgID)
			#print 'Message #%d \n' % i
			#print cipher

			if isMaul:
				maul(msg, recipient)
			#elif isAttack:
			#	attack(msg, recipient)
			else:
				logging.info('Intercepted message:')
				print '%s\n' % cipher
				#sendMSG(msgID, cipher, sender, recipient)

				logging.critical('cipher: ')
				print '\n%s' % cipher

				#Set adversary name and generate keys
				adversary = ''
				if msg.json()['messages'][i]['senderID'] == 'alice1':
					adversary = 'aloce1'
				else:
					adversary = 'bod2'
				genKeys(adversary)

				#get msgs for 'sender' to clear pending msgs on server
				getMessages(adversary)

				msgID = 0
				#1st Pass to determine padding length:
				for xor_pos in range(16):
					xor_char = 01
					msgID = xor_pos
					attack(msgID, cipher, adversary, recipient, xor_char, xor_pos, True) #TODO: REMOVE

				s.enter(5, 1, get_padlen, (adversary,))
				s.run()

				print '\n\n\n\n\ncompleted step 1. now step 2 \n\n\n'
				global padlen
				print padlen

				padded_cipher = format_padded_cipher(cipher, padlen)

				for xor_char in range(256):
					msgID = xor_char*100
					xor_pos = padlen

					attack(msgID, padded_cipher, adversary, recipient, xor_char, xor_pos, False)
				
				s.enter(10, 1, get_padlen, (adversary,))
				s.run()

				'''
				for xor_pos in range(4):
					for xor_char in range(16):
						msgID = (16-xor_pos)*100 + (xor_char)
						attack(msgID, cipher, adversary, recipient, xor_char, xor_pos) #TODO: REMOVE
				'''

def intercept(recipient, isMaul):

	logging.info('listening for messages to %s' % recipient)
	global intercepted_msg
	while 1==1:
		if not intercepted_msg:
			s.enter(0.5, 1, start_interception, (recipient, isMaul,))
			s.run()
		else:
			intercepted_msg = False
			return 0

if __name__ == "__main__":

	setupNetworkStrings(server, port)

	while 1==1:
		option = raw_input('> ')

		if 'i ' in option:
			intercept(option.split(" ")[1], False)
		elif 'maul ' in option:
			intercept(option.split(" ")[1], True)
		elif 'get ' in option:
			msg = getMessages(option.split(" ")[1])
			print msg.text

		#elif 'tap ' in option:
		#	print intercept(option.split(" ")[1])
		
	




